
## Создание базы данных и таблиц

### 1. Подключиться к СУБД

Сначала нужно подключиться к вашей СУБД (MySQL, PostgreSQL, SQL Server и т.д.) через DBeaver или pgAdmin 4

### 2. Создать базы данных
 
CREATE DATABASE filial1
    OWNER = postgres
    ENCODING = 'UTF8'
    CONNECTION LIMIT = -1;



CREATE DATABASE filial2
    OWNER = postgres
    ENCODING = 'UTF8'
    CONNECTION LIMIT = -1;



### 3. Создать одинаковые структуры в обеих базах:

**В базах filial1 и filial2** 

sql

-- Таблица должностей
CREATE TABLE Positions (
    PosCode INTEGER NOT NULL PRIMARY KEY,
    PosName VARCHAR(100) NOT NULL,
    ParentPos INTEGER NULL,
    Filial INTEGER NOT NULL
);

-- Таблица сотрудников
CREATE TABLE Employee (
    EmplCode INTEGER NOT NULL PRIMARY KEY,
    Name VARCHAR(50) NOT NULL,
    Surname VARCHAR(50) NOT NULL,
    Patronymic VARCHAR(50) NOT NULL,
    Birthday DATE NOT NULL,
    Passport VARCHAR(10) NOT NULL,
    PosCode INTEGER NOT NULL,
    Filial INTEGER NOT NULL,
    Status VARCHAR(20) DEFAULT 'Active',
    FOREIGN KEY (PosCode) REFERENCES Positions(PosCode)
);

-- Таблица истории изменений
CREATE TABLE EmplHistory (
    HistoryID SERIAL PRIMARY KEY,
    EmplCode INTEGER NOT NULL,
    ChangeDate DATE NOT NULL,
    Surname VARCHAR(50) NOT NULL,
    Passport VARCHAR(10) NOT NULL,
    PosCode INTEGER NOT NULL,
    Action VARCHAR(50) NOT NULL,
    FOREIGN KEY (EmplCode) REFERENCES Employee(EmplCode),
    FOREIGN KEY (PosCode) REFERENCES Positions(PosCode)
);

-- Таблица конфликтов
CREATE TABLE Conflist (
    ConflictID SERIAL PRIMARY KEY,
    EmplCode INTEGER NOT NULL,
    Errlist VARCHAR(1000) NOT NULL,
    ConflictDate TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    Resolved BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (EmplCode) REFERENCES Employee(EmplCode)
);


## 4. Заполнить тестовыми данными

**В обеих базах выполните:**

sql

-- Общие должности
INSERT INTO Positions (PosCode, PosName, ParentPos, Filial) VALUES
(1, 'Менедджер', NULL, 1),
(2, 'Разработчик', NULL, 1),
(3, 'Аналитик', NULL, 2),
(4, 'Дизайнер', NULL, 2);

-- Начальные сотрудники для Ф1
INSERT INTO Employee (EmplCode, Name, Surname, Patronymic, Birthday, Passport, PosCode, Filial) VALUES
(1001, 'Иван', 'Иванов', 'Иванович', '1990-01-01', '1234567890', 1, 1),
(1002, 'Петр', 'Петров', 'Петрович', '1991-02-02', '1111111111', 2, 1);

-- Начальные сотрудники для Ф2  
INSERT INTO Employee (EmplCode, Name, Surname, Patronymic, Birthday, Passport, PosCode, Filial) VALUES
(2001, 'Мария', 'Сидорова', 'Ивановна', '1992-03-03', '2222222222', 3, 2),
(2002, 'Анна', 'Смирнова', 'Петровна', '1993-04-04', '3333333333', 4, 2);

## 4. Утилиты для тестирования

### Функция для создания "снимка" данных:

sql

-- Создайте эту функцию в обеих базах
CREATE OR REPLACE FUNCTION make_data_snapshot()
RETURNS TABLE(
    table_name TEXT,
    record_count BIGINT,
    snapshot_time TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT 'Employee'::TEXT, COUNT(*)::BIGINT, NOW()
    FROM Employee
    UNION ALL
    SELECT 'Positions', COUNT(*), NOW()
    FROM Positions
    UNION ALL
    SELECT 'EmplHistory', COUNT(*), NOW()
    FROM EmplHistory
    UNION ALL
    SELECT 'Conflist', COUNT(*), NOW()
    FROM Conflist;
END;
$$ LANGUAGE plpgsql;

### Проверка согласованности данных:

sql

-- Функция для сравнения данных между филиалами
CREATE OR REPLACE FUNCTION compare_employees()
RETURNS TABLE(
    metric TEXT,
    filial1_count BIGINT,
    filial2_count BIGINT,
    difference BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 'Total Employees'::TEXT, 
           (SELECT COUNT(*) FROM Employee WHERE Filial = 1),
           (SELECT COUNT(*) FROM Employee WHERE Filial = 2),
           (SELECT COUNT(*) FROM Employee WHERE Filial = 1) - 
           (SELECT COUNT(*) FROM Employee WHERE Filial = 2);
END;
$$ LANGUAGE plpgsql;

## 5. Пример тестового сценария

### Тест 1: Добавление сотрудника в Ф1

sql

-- ШАГ 1: Фиксируем начальное состояние
SELECT * FROM make_data_snapshot();

-- ШАГ 2: Добавляем нового сотрудника в Ф1
INSERT INTO Employee (EmplCode, Name, Surname, Patronymic, Birthday, Passport, PosCode, Filial) 
VALUES (1003, 'Сергей', 'Козлов', 'Алексеевич', '1990-05-05', '4444444444', 2, 1);

-- ШАГ 3: Ждем синхронизации (в тестах можно эмулировать)
-- Здесь будет выполняться ваш job синхронизации

-- ШАГ 4: Проверяем результат
SELECT * FROM compare_employees();
SELECT * FROM Conflist; -- Проверяем конфликты

## 6. Автоматизация тестов

Создайте таблицу для хранения результатов тестов:

sql

CREATE TABLE test_results (
    test_id SERIAL PRIMARY KEY,
    test_name VARCHAR(200) NOT NULL,
    test_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expected_result TEXT,
    actual_result TEXT,
    test_status VARCHAR(20), -- PASSED/FAILED
    comments TEXT
);

Теперь у вас есть полноценное тестовое окружение для проверки синхронизации между двумя филиалами!
