
[DeepSeek - Into the Unknown](https://chat.deepseek.com/a/chat/s/4c154fc0-1821-4b04-bb8b-a1dbee385f28)



Отличное задание! Это классический пример интеграционного тестирования базы данных и ETL-процесса (синхронизации). Вот подробный план тестирования, составленный с учетом ваших требований.

### Общий Подход к Тестированию

1. **Подготовка тестового окружения:** Создание отдельных копий двух баз данных (Ф1 и Ф2) или использование специально выделенных для тестов сред.
    
2. **Метод "до-после":** Каждый тестовый сценарий будет выполняться по схеме:
    
    - **ШАГ 1 (Подготовка):** Фиксируем начальное состояние данных в обеих БД (делаем "снимки" ключевых таблиц).
        
    - **ШАГ 2 (Действие):** Выполняем операции в одной или обеих БД (найм, увольнение, изменение).
        
    - **ШАГ 3 (Ожидание):** Ждем выполнения ночного job синхронизации.
        
    - **ШАГ 4 (Проверка):** Фиксируем конечное состояние данных в обеих БД и журнале конфликтов. Сравниваем с ожидаемым результатом, используя SQL-запросы.
        
3. **Инструменты:** SQL-запросы (SELECT, JOIN, COUNT, EXCEPT/INTERSECT) для проверки данных. Можно использовать любой клиент БД или автоматизировать процесс с помощью Python/Java и библиотек для работы с БД.
    

---

### План тестирования для каждого кейса

#### **Тест-кейс 1: Синхронизация нового сотрудника из Ф1 в Ф2**

**Цель:** Убедиться, что сотрудник, нанятый в Ф1, после синхронизации становится доступен в Ф2.

**Шаги:**

1. **Подготовка:**
    
    - Очистить таблицы `Employee`, `EmplHistory`, `Conflist` в обеих БД.
        
    - Зафиксировать количество записей в `Employee` для Ф2.
        
2. **Действие:**
    
    - В БД Ф1 выполнить INSERT в таблицу `Employee` для нового сотрудника (например, `EmplCode=1001`, филиал Ф1).
        
    - В БД Ф1 выполнить INSERT в таблицу `EmplHistory` для этого сотрудника.
        
3. **Ожидание:** Запустить и дождаться успешного выполнения процедуры синхронизации.
    
4. **Проверка (SQL-запросы):**
    
    - **Наличие в Ф2:** `SELECT COUNT(*) FROM Employee WHERE EmplCode = 1001 AND Filial = 2;` (Ожидаемый результат: 1).
        
    - **Целостность данных:** Сравнить все поля сотрудника `EmplCode=1001` между Ф1 и Ф2. Они должны совпадать.
        
    - **История:** Проверить, что в `EmplHistory` Ф2 появилась соответствующая запись.
        
    - **Отсутствие конфликта:** `SELECT COUNT(*) FROM Conflist WHERE EmplCode = 1001;` (Ожидаемый результат: 0).
        

---

#### **Тест-кейс 2: Синхронизация увольнения сотрудника из Ф2 в Ф1**

**Цель:** Убедиться, что уволенный сотрудник в Ф2 после синхронизации помечается как уволенный в Ф1.

_Примечание: В вашей схеме нет явного поля "Status" (уволен/работает). Предполагается, что факт увольнения фиксируется либо удалением записи из `Employee` (что плохая практика), либо добавлением записи в `EmplHistory` с признаком увольнения. Я предположу второй, более правильный вариант, и для этого потребуется добавить в `EmplHistory` поле `Action` (например, 'Hired', 'Fired'). Без такого поля тестирование этого сценария невозможно._

**Шаги (с учетом поля `Action`):**

1. **Подготовка:**
    
    - Добавить в обе БД сотрудника с `EmplCode=2001` в филиале Ф2.
        
2. **Действие:**
    
    - В БД Ф2 выполнить INSERT в `EmplHistory` для `EmplCode=2001` с `Action = 'Fired'`.
        
3. **Ожидание:** Запустить синхронизацию.
    
4. **Проверка:**
    
    - **Статус в Ф1:** `SELECT COUNT(*) FROM EmplHistory WHERE EmplCode = 2001 AND Action = 'Fired';` (Ожидаемый результат: 1).
        

---

#### **Тест-кейс 3: Обработка дублирования сотрудников (полное совпадение)**

**Цель:** Убедиться, что при полном совпадении ключевых атрибутов дублирования не происходит.

**Шаги:**

1. **Подготовка:** Очистить связанные таблицы.
    
2. **Действие:**
    
    - В БД Ф1 выполнить INSERT сотрудника (Иванов Иван Иванович, 01.01.1990, паспорт 1234567890).
        
    - В БД Ф2 выполнить INSERT сотрудника с **такими же** `Name`, `Surname`, `Patronymic`, `Birthday`, `Passport`.
        
3. **Ожидание:** Запустить синхронизацию.
    
4. **Проверка:**
    
    - **Количество сотрудников:** Посчитать общее количество уникальных сотрудников по связке ФИО+ДатаРождения+Паспорт. Должен остаться один.
        
    - **Проверка через объединение:**
        
        sql
        
        -- Этот запрос должен вернуть 0 строк, если дублей нет
        SELECT Surname, Name, Patronymic, Birthday, Passport, COUNT(*)
        FROM (
            SELECT * FROM Employee WHERE Filial = 1
            UNION ALL
            SELECT * FROM Employee WHERE Filial = 2
        ) AS AllEmpl
        GROUP BY Surname, Name, Patronymic, Birthday, Passport
        HAVING COUNT(*) > 1;
        

---

#### **Тест-кейс 4: Обработка конфликта (частичное совпадение)**

**Цель:** Убедиться, что при совпадении 2 из 3 ключевых параметров синхронизация не выполняется, а информация идет в журнал конфликтов.

**Шаги:**

1. **Подготовка:** Очистить связанные таблицы.
    
2. **Действие:**
    
    - В БД Ф1 добавить сотрудника (Петров Петр Петрович, 02.02.1991, паспорт 1111111111).
        
    - В БД Ф2 добавить сотрудника (Петров Петр Петрович, 02.02.1991, паспорт **9999999999**). // Совпали ФИО и Дата Рождения, но не паспорт.
        
3. **Ожидание:** Запустить синхронизацию.
    
4. **Проверка:**
    
    - **Журнал конфликтов:** `SELECT COUNT(*) FROM Conflist WHERE EmplCode IN (код_из_Ф1, код_из_Ф2);` (Ожидаемый результат: >=1). Желательно также проверить текст ошибки в `Errlist`.
        
    - **Отсутствие изменений:** Убедиться, что данные этих двух сотрудников в обеих БД остались неизменными (не были перезаписаны друг другом).
        

---

#### **Тест-кейс 5: Разрешение конфликта экспертами**

**Цель:** Убедиться, что после ручного разрешения конфликта синхронизация происходит корректно.

**Шаги:**

1. **Подготовка:** Создать конфликтную ситуацию, как в Тест-кейсе 4. Убедиться, что запись есть в `Conflist`.
    
2. **Действие (Имитация работы экспертов):**
    
    - Предположим, что правильными данными являются данные из Ф1.
        
    - Вручную обновить данные сотрудника в Ф2, приведя их в полное соответствие с данными в Ф1 (или наоборот).
        
    - Удалить запись из `Conflist` (или изменить ее статус, если он есть, на 'Resolved').
        
3. **Ожидание:** Запустить следующую ночную синхронизацию.
    
4. **Проверка:**
    
    - **Дублирование:** Проверить отсутствие дублирования (аналогично Тест-кейсу 3).
        
    - **Журнал конфликтов:** Убедиться, что запись о данном конфликте удалена из `Conflist`.
        
    - **Целостность данных:** Данные о сотруднике должны быть идентичны в обеих БД.
        

---

#### **Тест-кейс 6: Сохранение истории изменений**

**Цель:** Убедиться, что при синхронизации изменений (должность, оклад) история изменений не нарушается.

**Шаги:**

1. **Подготовка:**
    
    - Добавить сотрудника в Ф1. Синхронизировать, чтобы он появился в Ф2.
        
    - Зафиксировать количество записей в `EmplHistory` для этого сотрудника в обеих БД.
        
2. **Действие:**
    
    - В БД Ф1 изменить данные сотрудника (например, `Surname` или `PosCode`).
        
    - В БД Ф1 выполнить INSERT в `EmplHistory`, фиксирующий это изменение.
        
3. **Ожидание:** Запустить синхронизацию.
    
4. **Проверка:**
    
    - **Актуальные данные:** Убедиться, что в БД Ф2 в таблице `Employee` данные сотрудника обновились.
        
    - **История в Ф2:** `SELECT COUNT(*) FROM EmplHistory WHERE EmplCode = <код_сотрудника>;` Количество записей должно увеличиться на 1 по сравнению с начальным состоянием.
        
    - **Корректность истории:** Новая запись в `EmplHistory` Ф2 должна точно соответствовать новой записи в `EmplHistory` Ф1 по полям `Surname`, `Passport`, `PosCode` и `ChangeDate`.
        

### Дополнительные рекомендации

1. **Тестовые данные:** Используйте четкие, уникальные тестовые данные (например, паспорта "ТЕСТ0001", "ТЕСТ0002"), чтобы не пересекаться с реальными данными.
    
2. **Автоматизация:** Эти тесты идеально подходят для автоматизации. Напишите скрипты на Python (с использованием `pytest` и библиотек `pyodbc`/`psycopg2`) или на Java (JDBC), которые будут выполнять подготовку, действие и проверку.
    
3. **Проверка целостности:** Помимо специфических проверок, после каждого прогона синхронизации полезно делать общие проверки на целостность данных: отсутствие "битых" FK, соответствие количества записей после синхронизации и т.д.
    
4. **Негативное тестирование:** Добавьте тесты с некорректными данными (например, NULL в обязательных полях) на стороне-источнике, чтобы проверить, как система синхронизации обрабатывает ошибки.
    

Этот план покрывает все поставленные требования и дает надежную основу для проверки корректности работы процедур синхронизации.