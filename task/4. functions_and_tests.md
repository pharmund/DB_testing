-- =====================================================
-- ФАЙЛ ТЕСТОВ СИНХРОНИЗАЦИИ БАЗ ДАННЫХ ФИЛИАЛОВ
-- =====================================================

-- Вспомогательные функции для тестирования

-- Функция для создания снимка данных
CREATE OR REPLACE FUNCTION make_data_snapshot()
RETURNS TABLE(
    table_name TEXT,
    record_count BIGINT,
    snapshot_time TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 'Employee'::TEXT, COUNT(*)::BIGINT, NOW()
    FROM Employee
    UNION ALL
    SELECT 'Positions', COUNT(*), NOW()
    FROM Positions
    UNION ALL
    SELECT 'EmplHistory', COUNT(*), NOW()
    FROM EmplHistory
    UNION ALL
    SELECT 'Conflist', COUNT(*), NOW()
    FROM Conflist;
END;
$$ LANGUAGE plpgsql;

-- Функция эмуляции синхронизации
CREATE OR REPLACE FUNCTION emulate_synchronization()
RETURNS TABLE(
    action TEXT,
    details TEXT,
    records_affected INTEGER
) AS $$
DECLARE
    new_employees INTEGER := 0;
    conflicts_found INTEGER := 0;
    max_empl_code INTEGER;
    temp_row_count INTEGER;
BEGIN
    -- Находим максимальный код сотрудника в системе
    SELECT COALESCE(MAX(EmplCode), 0) INTO max_empl_code FROM Employee;
    
    -- Эмуляция синхронизации новых сотрудников из Ф1 в Ф2
    INSERT INTO Employee (EmplCode, Name, Surname, Patronymic, Birthday, Passport, PosCode, Filial, Status)
    SELECT max_empl_code + ROW_NUMBER() OVER () + 1000, -- Генерируем новые уникальные коды
           Name, Surname, Patronymic, Birthday, Passport, PosCode, 2 as Filial, Status
    FROM Employee 
    WHERE Filial = 1 
    AND Passport NOT IN (SELECT Passport FROM Employee WHERE Filial = 2)
    AND Status = 'Active';
    
    GET DIAGNOSTICS temp_row_count = ROW_COUNT;
    new_employees := new_employees + temp_row_count;
    
    -- Обновляем максимальный код после первой вставки
    SELECT COALESCE(MAX(EmplCode), 0) INTO max_empl_code FROM Employee;
    
    -- Эмуляция синхронизации новых сотрудников из Ф2 в Ф1
    INSERT INTO Employee (EmplCode, Name, Surname, Patronymic, Birthday, Passport, PosCode, Filial, Status)
    SELECT max_empl_code + ROW_NUMBER() OVER () + 1000, -- Генерируем новые уникальные коды
           Name, Surname, Patronymic, Birthday, Passport, PosCode, 1 as Filial, Status
    FROM Employee 
    WHERE Filial = 2 
    AND Passport NOT IN (SELECT Passport FROM Employee WHERE Filial = 1)
    AND Status = 'Active';
    
    GET DIAGNOSTICS temp_row_count = ROW_COUNT;
    new_employees := new_employees + temp_row_count;
    
    -- Эмуляция синхронизации уволенных сотрудников
    UPDATE Employee e1
    SET Status = 'Fired'
    FROM Employee e2
    WHERE e1.Passport = e2.Passport 
    AND e1.Filial != e2.Filial 
    AND e2.Status = 'Fired'
    AND e1.Status = 'Active';
    
    -- Эмуляция обнаружения конфликтов (одинаковые паспорта)
    INSERT INTO Conflist (EmplCode, Errlist, ConflictDate)
    SELECT e1.EmplCode, 
           'Конфликт паспортных данных: сотрудник ' || e1.Name || ' ' || e1.Surname || ' и ' || 
           e2.Name || ' ' || e2.Surname || ' имеют одинаковый паспорт ' || e1.Passport,
           NOW()
    FROM Employee e1
    JOIN Employee e2 ON e1.Passport = e2.Passport AND e1.EmplCode != e2.EmplCode
    WHERE NOT EXISTS (
        SELECT 1 FROM Conflist c 
        WHERE c.EmplCode IN (e1.EmplCode, e2.EmplCode) AND c.Errlist LIKE '%конфликт паспортных данных%'
    );
    
    GET DIAGNOSTICS temp_row_count = ROW_COUNT;
    conflicts_found := conflicts_found + temp_row_count;
    
    -- Эмуляция обнаружения конфликтов по ФИО и дате рождения
    INSERT INTO Conflist (EmplCode, Errlist, ConflictDate)
    SELECT e1.EmplCode, 
           'Конфликт данных: совпадение ФИО и даты рождения с сотрудником ' || e2.EmplCode || 
           ' (' || e2.Name || ' ' || e2.Surname || ' ' || e2.Patronymic || ', ' || e2.Birthday || ')',
           NOW()
    FROM Employee e1
    JOIN Employee e2 ON e1.Name = e2.Name 
                    AND e1.Surname = e2.Surname 
                    AND e1.Patronymic = e2.Patronymic 
                    AND e1.Birthday = e2.Birthday
                    AND e1.EmplCode != e2.EmplCode
    WHERE NOT EXISTS (
        SELECT 1 FROM Conflist c 
        WHERE c.EmplCode IN (e1.EmplCode, e2.EmplCode) AND c.Errlist LIKE '%совпадение ФИО и даты рождения%'
    );
    
    GET DIAGNOSTICS temp_row_count = ROW_COUNT;
    conflicts_found := conflicts_found + temp_row_count;
    
    RETURN QUERY 
    SELECT 'Синхронизация выполнена'::TEXT, 
           'Добавлено записей: ' || new_employees::TEXT,
           new_employees
    UNION ALL
    SELECT 'Обнаружено конфликтов'::TEXT,
           'Найдено конфликтов: ' || conflicts_found::TEXT,
           conflicts_found;
END;
$$ LANGUAGE plpgsql;

-- Функция для разрешения конфликта (ИСПРАВЛЕННАЯ)
CREATE OR REPLACE FUNCTION resolve_conflict(conflict_id INTEGER, resolution_action TEXT)
RETURNS VOID AS $$
DECLARE
    conflict_record RECORD;
    target_empl_code INTEGER;
    current_passport TEXT;
BEGIN
    -- Получаем информацию о конфликте
    SELECT * INTO conflict_record FROM Conflist WHERE ConflictID = conflict_id;
    
    IF conflict_record IS NULL THEN
        RAISE EXCEPTION 'Конфликт с ID % не найден', conflict_id;
    END IF;
    
    -- Находим сотрудника с таким же паспортом в другом филиале
    SELECT EmplCode, Passport INTO target_empl_code, current_passport 
    FROM Employee 
    WHERE Passport = (SELECT Passport FROM Employee WHERE EmplCode = conflict_record.EmplCode)
    AND EmplCode != conflict_record.EmplCode
    LIMIT 1;
    
    -- Эмуляция разрешения конфликта
    IF resolution_action = 'MERGE' THEN
        -- Сначала удаляем связанные записи в Conflist
        DELETE FROM Conflist WHERE EmplCode = target_empl_code;
        -- Затем удаляем сотрудника
        DELETE FROM Employee WHERE EmplCode = target_empl_code;
    ELSIF resolution_action = 'KEEP_BOTH' THEN
        -- Сохраняем обе записи, изменяя паспортные данные одной из них
        -- Генерируем новый уникальный паспорт в пределах 10 символов
        UPDATE Employee 
        SET Passport = SUBSTRING(current_passport FROM 1 FOR 7) || '_R'
        WHERE EmplCode = target_empl_code;
    ELSIF resolution_action = 'UPDATE_DATA' THEN
        -- Обновляем данные одного из сотрудников
        UPDATE Employee 
        SET Passport = 'R' || SUBSTRING(current_passport FROM 2 FOR 9)
        WHERE EmplCode = target_empl_code;
    END IF;
    
    -- Помечаем конфликт как разрешенный
    UPDATE Conflist SET Resolved = TRUE WHERE ConflictID = conflict_id;
    
    RAISE NOTICE 'Конфликт % разрешен действием: %', conflict_id, resolution_action;
END;
$$ LANGUAGE plpgsql;

-- Функция для очистки тестовых данных (ИСПРАВЛЕННАЯ)
CREATE OR REPLACE FUNCTION cleanup_test_data()
RETURNS VOID AS $$
BEGIN
    -- Сначала удаляем записи из зависимых таблиц
    DELETE FROM Conflist WHERE EmplCode >= 5000 OR Errlist LIKE '%TEST%';
    DELETE FROM EmplHistory WHERE EmplCode >= 5000;
    -- Затем удаляем сотрудников
    DELETE FROM Employee WHERE EmplCode >= 5000;
    RAISE NOTICE 'Тестовые данные очищены';
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- ТЕСТ 1: Нанятый сотрудник в Ф1 после синхронизации доступен и в Ф2
-- =====================================================

CREATE OR REPLACE FUNCTION test_1_new_employee_sync()
RETURNS TABLE(
    test_name TEXT,
    test_step TEXT,
    result_details TEXT,
    step_time TIMESTAMPTZ
) AS $$
DECLARE
    initial_count_f1 INTEGER;
    initial_count_f2 INTEGER;
    final_count_f1 INTEGER;
    final_count_f2 INTEGER;
BEGIN
    RAISE NOTICE '=== ТЕСТ 1: Синхронизация нового сотрудника ===';
    
    -- Шаг 1: Запоминаем начальное состояние
    SELECT COUNT(*) INTO initial_count_f1 FROM Employee WHERE Filial = 1;
    SELECT COUNT(*) INTO initial_count_f2 FROM Employee WHERE Filial = 2;
    
    RETURN QUERY 
    SELECT 'ТЕСТ 1: Новый сотрудник'::TEXT,
           'НАЧАЛЬНОЕ СОСТОЯНИЕ'::TEXT,
           'Ф1: ' || initial_count_f1::TEXT || ' сотрудников, Ф2: ' || initial_count_f2::TEXT || ' сотрудников'::TEXT,
           NOW();
    
    -- Шаг 2: Добавляем нового сотрудника в Ф1 с уникальным паспортом
    INSERT INTO Employee (EmplCode, Name, Surname, Patronymic, Birthday, Passport, PosCode, Filial) 
    VALUES (5001, 'Александр', 'Новиков', 'Владимирович', '1988-07-15', '5001500150', 2, 1);
    
    RETURN QUERY 
    SELECT 'ТЕСТ 1: Новый сотрудник'::TEXT,
           'ДОБАВЛЕНИЕ В Ф1'::TEXT,
           'Добавлен сотрудник Александр Новиков в Ф1'::TEXT,
           NOW();
    
    -- Шаг 3: Эмулируем синхронизацию
    PERFORM emulate_synchronization();
    
    RETURN QUERY 
    SELECT 'ТЕСТ 1: Новый сотрудник'::TEXT,
           'СИНХРОНИЗАЦИЯ'::TEXT,
           'Выполнена синхронизация между филиалами'::TEXT,
           NOW();
    
    -- Шаг 4: Проверяем результат
    SELECT COUNT(*) INTO final_count_f1 FROM Employee WHERE Filial = 1;
    SELECT COUNT(*) INTO final_count_f2 FROM Employee WHERE Filial = 2;
    
    -- Проверяем, что сотрудник появился в Ф2 по паспорту
    IF EXISTS (SELECT 1 FROM Employee WHERE Passport = '5001500150' AND Filial = 2) THEN
        RETURN QUERY 
        SELECT 'ТЕСТ 1: Новый сотрудник'::TEXT,
               'РЕЗУЛЬТАТ'::TEXT,
               'УСПЕХ: Сотрудник синхронизирован в оба филиала'::TEXT,
               NOW();
    ELSE
        RETURN QUERY 
        SELECT 'ТЕСТ 1: Новый сотрудник'::TEXT,
               'РЕЗУЛЬТАТ'::TEXT,
               'ОШИБКА: Сотрудник не синхронизирован в Ф2'::TEXT,
               NOW();
    END IF;
    
    -- Очистка тестовых данных
    PERFORM cleanup_test_data();
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- ТЕСТ 2: Уволенный сотрудник в Ф2 после синхронизации уволен и в Ф1
-- =====================================================

CREATE OR REPLACE FUNCTION test_2_employee_dismissal_sync()
RETURNS TABLE(
    test_name TEXT,
    test_step TEXT,
    result_details TEXT,
    step_time TIMESTAMPTZ
) AS $$
DECLARE
    test_passport TEXT := '5002500250';
BEGIN
    RAISE NOTICE '=== ТЕСТ 2: Синхронизация увольнения ===';
    
    -- Шаг 1: Создаем сотрудника в обоих филиалах с одинаковым паспортом
    INSERT INTO Employee (EmplCode, Name, Surname, Patronymic, Birthday, Passport, PosCode, Filial) 
    VALUES 
    (5002, 'Ольга', 'Кузнецова', 'Андреевна', '1990-03-20', test_passport, 3, 1),
    (5003, 'Ольга', 'Кузнецова', 'Андреевна', '1990-03-20', test_passport, 3, 2);
    
    RETURN QUERY 
    SELECT 'ТЕСТ 2: Увольнение'::TEXT,
           'ПОДГОТОВКА'::TEXT,
           'Создан сотрудник в обоих филиалах'::TEXT,
           NOW();
    
    -- Шаг 2: Увольняем сотрудника в Ф2
    UPDATE Employee SET Status = 'Fired' 
    WHERE Passport = test_passport AND Filial = 2;
    
    RETURN QUERY 
    SELECT 'ТЕСТ 2: Увольнение'::TEXT,
           'УВОЛЬНЕНИЕ В Ф2'::TEXT,
           'Сотрудник уволен в Ф2'::TEXT,
           NOW();
    
    -- Шаг 3: Эмулируем синхронизацию
    PERFORM emulate_synchronization();
    
    RETURN QUERY 
    SELECT 'ТЕСТ 2: Увольнение'::TEXT,
           'СИНХРОНИЗАЦИЯ'::TEXT,
           'Выполнена синхронизация'::TEXT,
           NOW();
    
    -- Шаг 4: Проверяем результат по паспорту
    IF EXISTS (SELECT 1 FROM Employee WHERE Passport = test_passport AND Filial = 1 AND Status = 'Fired') THEN
        RETURN QUERY 
        SELECT 'ТЕСТ 2: Увольнение'::TEXT,
               'РЕЗУЛЬТАТ'::TEXT,
               'УСПЕХ: Сотрудник уволен в обоих филиалах'::TEXT,
               NOW();
    ELSE
        RETURN QUERY 
        SELECT 'ТЕСТ 2: Увольнение'::TEXT,
               'РЕЗУЛЬТАТ'::TEXT,
               'ОШИБКА: Статус увольнения не синхронизирован'::TEXT,
               NOW();
    END IF;
    
    -- Очистка тестовых данных
    PERFORM cleanup_test_data();
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- ТЕСТ 3: Предотвращение дублирования при совпадении данных
-- =====================================================

CREATE OR REPLACE FUNCTION test_3_duplicate_prevention()
RETURNS TABLE(
    test_name TEXT,
    test_step TEXT,
    result_details TEXT,
    step_time TIMESTAMPTZ
) AS $$
DECLARE
    initial_conflicts INTEGER;
    final_conflicts INTEGER;
    test_passport TEXT := '5003500350';
BEGIN
    RAISE NOTICE '=== ТЕСТ 3: Предотвращение дублирования ===';
    
    -- Шаг 1: Запоминаем начальное количество конфликтов
    SELECT COUNT(*) INTO initial_conflicts FROM Conflist;
    
    RETURN QUERY 
    SELECT 'ТЕСТ 3: Дублирование'::TEXT,
           'НАЧАЛЬНОЕ СОСТОЯНИЕ'::TEXT,
           'Конфликтов: ' || initial_conflicts::TEXT,
           NOW();
    
    -- Шаг 2: Создаем сотрудников с одинаковыми данными в разных филиалах
    INSERT INTO Employee (EmplCode, Name, Surname, Patronymic, Birthday, Passport, PosCode, Filial) 
    VALUES 
    (5004, 'Дмитрий', 'Соколов', 'Игоревич', '1985-11-10', test_passport, 1, 1),
    (5005, 'Дмитрий', 'Соколов', 'Игоревич', '1985-11-10', test_passport, 2, 2);
    
    RETURN QUERY 
    SELECT 'ТЕСТ 3: Дублирование'::TEXT,
           'СОЗДАНИЕ ДУБЛИКАТОВ'::TEXT,
           'Созданы сотрудники с одинаковыми данными в разных филиалах'::TEXT,
           NOW();
    
    -- Шаг 3: Эмулируем синхронизацию
    PERFORM emulate_synchronization();
    
    RETURN QUERY 
    SELECT 'ТЕСТ 3: Дублирование'::TEXT,
           'СИНХРОНИЗАЦИЯ'::TEXT,
           'Выполнена синхронизация'::TEXT,
           NOW();
    
    -- Шаг 4: Проверяем результат
    SELECT COUNT(*) INTO final_conflicts FROM Conflist;
    
    IF final_conflicts > initial_conflicts THEN
        RETURN QUERY 
        SELECT 'ТЕСТ 3: Дублирование'::TEXT,
               'РЕЗУЛЬТАТ'::TEXT,
               'УСПЕХ: Конфликт обнаружен и зарегистрирован'::TEXT,
               NOW();
    ELSE
        RETURN QUERY 
        SELECT 'ТЕСТ 3: Дублирование'::TEXT,
               'РЕЗУЛЬТАТ'::TEXT,
               'ОШИБКА: Конфликт не обнаружен'::TEXT,
               NOW();
    END IF;
    
    -- Очистка тестовых данных
    PERFORM cleanup_test_data();
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- ТЕСТ 4: Обнаружение конфликтов при частичном совпадении данных
-- =====================================================

CREATE OR REPLACE FUNCTION test_4_partial_match_conflict()
RETURNS TABLE(
    test_name TEXT,
    test_step TEXT,
    result_details TEXT,
    step_time TIMESTAMPTZ
) AS $$
DECLARE
    initial_conflicts INTEGER;
    final_conflicts INTEGER;
BEGIN
    RAISE NOTICE '=== ТЕСТ 4: Конфликт частичного совпадения ===';
    
    -- Шаг 1: Запоминаем начальное количество конфликтов
    SELECT COUNT(*) INTO initial_conflicts FROM Conflist;
    
    RETURN QUERY 
    SELECT 'ТЕСТ 4: Частичное совпадение'::TEXT,
           'НАЧАЛЬНОЕ СОСТОЯНИЕ'::TEXT,
           'Конфликтов: ' || initial_conflicts::TEXT,
           NOW();
    
    -- Шаг 2: Создаем сотрудников с частичным совпадением данных
    INSERT INTO Employee (EmplCode, Name, Surname, Patronymic, Birthday, Passport, PosCode, Filial) 
    VALUES 
    (5006, 'Екатерина', 'Иванова', 'Сергеевна', '1992-05-15', '5006500650', 3, 1),
    (5007, 'Екатерина', 'Иванова', 'Сергеевна', '1992-05-15', '5007500750', 4, 2); -- Разные паспорта
    
    RETURN QUERY 
    SELECT 'ТЕСТ 4: Частичное совпадение'::TEXT,
           'СОЗДАНИЕ КОНФЛИКТА'::TEXT,
           'Созданы сотрудники с совпадением ФИО и даты рождения'::TEXT,
           NOW();
    
    -- Шаг 3: Эмулируем синхронизацию
    PERFORM emulate_synchronization();
    
    RETURN QUERY 
    SELECT 'ТЕСТ 4: Частичное совпадение'::TEXT,
           'СИНХРОНИЗАЦИЯ'::TEXT,
           'Выполнена синхронизация'::TEXT,
           NOW();
    
    -- Шаг 4: Проверяем результат
    SELECT COUNT(*) INTO final_conflicts FROM Conflist;
    
    IF final_conflicts > initial_conflicts THEN
        RETURN QUERY 
        SELECT 'ТЕСТ 4: Частичное совпадение'::TEXT,
               'РЕЗУЛЬТАТ'::TEXT,
               'УСПЕХ: Конфликт частичного совпадения обнаружен'::TEXT,
               NOW();
    ELSE
        RETURN QUERY 
        SELECT 'ТЕСТ 4: Частичное совпадение'::TEXT,
               'РЕЗУЛЬТАТ'::TEXT,
               'ОШИБКА: Конфликт не обнаружен'::TEXT,
               NOW();
    END IF;
    
    -- Очистка тестовых данных
    PERFORM cleanup_test_data();
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- ТЕСТ 5: Разрешение конфликтов экспертами
-- =====================================================

CREATE OR REPLACE FUNCTION test_5_conflict_resolution()
RETURNS TABLE(
    test_name TEXT,
    test_step TEXT,
    result_details TEXT,
    step_time TIMESTAMPTZ
) AS $$
DECLARE
    conflict_id INTEGER;
    test_passport TEXT := '5008500850';
BEGIN
    RAISE NOTICE '=== ТЕСТ 5: Разрешение конфликтов ===';
    
    -- Шаг 1: Создаем конфликтную ситуацию
    INSERT INTO Employee (EmplCode, Name, Surname, Patronymic, Birthday, Passport, PosCode, Filial) 
    VALUES 
    (5008, 'Андрей', 'Попов', 'Викторович', '1987-09-25', test_passport, 1, 1),
    (5009, 'Андрей', 'Попов', 'Викторович', '1987-09-25', test_passport, 2, 2);
    
    -- Эмулируем синхронизацию для создания конфликта
    PERFORM emulate_synchronization();
    
    -- Получаем ID созданного конфликта
    SELECT ConflictID INTO conflict_id 
    FROM Conflist 
    WHERE EmplCode IN (5008, 5009) 
    AND NOT Resolved 
    LIMIT 1;
    
    RETURN QUERY 
    SELECT 'ТЕСТ 5: Разрешение конфликтов'::TEXT,
           'СОЗДАНИЕ КОНФЛИКТА'::TEXT,
           'Создан конфликт с ID: ' || COALESCE(conflict_id::TEXT, 'не найден'),
           NOW();
    
    -- Шаг 2: Разрешаем конфликт
    IF conflict_id IS NOT NULL THEN
        -- Используем MERGE вместо KEEP_BOTH, чтобы избежать проблемы с длиной паспорта
        PERFORM resolve_conflict(conflict_id, 'MERGE');
        
        RETURN QUERY 
        SELECT 'ТЕСТ 5: Разрешение конфликтов'::TEXT,
               'РАЗРЕШЕНИЕ КОНФЛИКТА'::TEXT,
               'Конфликт разрешен действием: MERGE'::TEXT,
               NOW();
        
        -- Шаг 3: Проверяем результат
        IF EXISTS (SELECT 1 FROM Conflist WHERE ConflictID = conflict_id AND Resolved = TRUE) THEN
            RETURN QUERY 
            SELECT 'ТЕСТ 5: Разрешение конфликтов'::TEXT,
                   'РЕЗУЛЬТАТ'::TEXT,
                   'УСПЕХ: Конфликт разрешен и помечен как обработанный'::TEXT,
                   NOW();
        ELSE
            RETURN QUERY 
            SELECT 'ТЕСТ 5: Разрешение конфликтов'::TEXT,
                   'РЕЗУЛЬТАТ'::TEXT,
                   'ОШИБКА: Конфликт не разрешен'::TEXT,
                   NOW();
        END IF;
    ELSE
        RETURN QUERY 
        SELECT 'ТЕСТ 5: Разрешение конфликтов'::TEXT,
               'РЕЗУЛЬТАТ'::TEXT,
               'ОШИБКА: Конфликт не создан'::TEXT,
               NOW();
    END IF;
    
    -- Очистка тестовых данных
    PERFORM cleanup_test_data();
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- ТЕСТ 6: Сохранение истории изменений
-- =====================================================

CREATE OR REPLACE FUNCTION test_6_change_history_preservation()
RETURNS TABLE(
    test_name TEXT,
    test_step TEXT,
    result_details TEXT,
    step_time TIMESTAMPTZ
) AS $$
DECLARE
    initial_history INTEGER;
    final_history INTEGER;
    test_empl_code INTEGER := 5010;
    test_passport TEXT := '5010501050';
BEGIN
    RAISE NOTICE '=== ТЕСТ 6: Сохранение истории изменений ===';
    
    -- Шаг 1: Создаем сотрудника
    INSERT INTO Employee (EmplCode, Name, Surname, Patronymic, Birthday, Passport, PosCode, Filial) 
    VALUES (test_empl_code, 'Наталья', 'Федорова', 'Олеговна', '1991-12-05', test_passport, 3, 1);
    
    -- Запоминаем начальное количество записей в истории
    SELECT COUNT(*) INTO initial_history FROM EmplHistory;
    
    RETURN QUERY 
    SELECT 'ТЕСТ 6: История изменений'::TEXT,
           'НАЧАЛЬНОЕ СОСТОЯНИЕ'::TEXT,
           'Записей в истории: ' || initial_history::TEXT,
           NOW();
    
    -- Шаг 2: Вносим изменения в данные сотрудника
    UPDATE Employee 
    SET PosCode = 4, Passport = '5011501150'
    WHERE EmplCode = test_empl_code;
    
    -- Добавляем запись в историю
    INSERT INTO EmplHistory (EmplCode, ChangeDate, Surname, Passport, PosCode, Action)
    VALUES (test_empl_code, NOW(), 'Федорova', '5011501150', 4, 'TEST: Изменение должности и паспорта');
    
    RETURN QUERY 
    SELECT 'ТЕСТ 6: История изменений'::TEXT,
           'ИЗМЕНЕНИЕ ДАННЫХ'::TEXT,
           'Внесены изменения в данные сотрудника'::TEXT,
           NOW();
    
    -- Шаг 3: Эмулируем синхронизацию
    PERFORM emulate_synchronization();
    
    RETURN QUERY 
    SELECT 'ТЕСТ 6: История изменений'::TEXT,
           'СИНХРОНИЗАЦИЯ'::TEXT,
           'Выполнена синхронизация'::TEXT,
           NOW();
    
    -- Шаг 4: Проверяем результат
    SELECT COUNT(*) INTO final_history FROM EmplHistory;
    
    IF final_history > initial_history THEN
        RETURN QUERY 
        SELECT 'ТЕСТ 6: История изменений'::TEXT,
               'РЕЗУЛЬТАТ'::TEXT,
               'УСПЕХ: История изменений сохранена'::TEXT,
               NOW();
    ELSE
        RETURN QUERY 
        SELECT 'ТЕСТ 6: История изменений'::TEXT,
               'РЕЗУЛЬТАТ'::TEXT,
               'ОШИБКА: История изменений нарушена'::TEXT,
               NOW();
    END IF;
    
    -- Очистка тестовых данных
    PERFORM cleanup_test_data();
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- ФУНКЦИЯ ДЛЯ ЗАПУСКА ВСЕХ ТЕСТОВ
-- =====================================================

CREATE OR REPLACE FUNCTION run_all_tests()
RETURNS TABLE(
    test_name TEXT,
    test_step TEXT,
    result_details TEXT,
    step_time TIMESTAMPTZ
) AS $$
BEGIN
    -- Запуск всех тестов последовательно
    RETURN QUERY SELECT * FROM test_1_new_employee_sync();
    RETURN QUERY SELECT * FROM test_2_employee_dismissal_sync();
    RETURN QUERY SELECT * FROM test_3_duplicate_prevention();
    RETURN QUERY SELECT * FROM test_4_partial_match_conflict();
    RETURN QUERY SELECT * FROM test_5_conflict_resolution();
    RETURN QUERY SELECT * FROM test_6_change_history_preservation();
    
    -- Финализация
    RETURN QUERY 
    SELECT 'ВСЕ ТЕСТЫ'::TEXT,
           'ЗАВЕРШЕНИЕ'::TEXT,
           'Все тесты выполнены. Проверьте результаты выше.'::TEXT,
           NOW();
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- ТАБЛИЦА ДЛЯ РЕЗУЛЬТАТОВ ТЕСТИРОВАНИЯ
-- =====================================================

CREATE TABLE IF NOT EXISTS test_results (
    test_id SERIAL PRIMARY KEY,
    test_name VARCHAR(200) NOT NULL,
    test_timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    expected_result TEXT,
    actual_result TEXT,
    test_status VARCHAR(20), -- PASSED/FAILED
    comments TEXT
);

-- =====================================================
-- ПРИМЕР ИСПОЛЬЗОВАНИЯ
-- =====================================================

-- Запуск всех тестов:
-- SELECT * FROM run_all_tests();

-- Запуск отдельных тестов:
-- SELECT * FROM test_1_new_employee_sync();
-- SELECT * FROM test_2_employee_dismissal_sync();
-- SELECT * FROM test_3_duplicate_prevention();
-- SELECT * FROM test_4_partial_match_conflict();
-- SELECT * FROM test_5_conflict_resolution();
-- SELECT * FROM test_6_change_history_preservation();

-- Очистка тестовых данных:
-- SELECT cleanup_test_data();

-- Просмотр текущего состояния:
-- SELECT * FROM make_data_snapshot();