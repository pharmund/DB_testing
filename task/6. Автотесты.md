Отличный план! Вот готовые автотесты на Python для вашей системы синхронизации между филиалами:

[DeepSeek - Into the Unknown](https://chat.deepseek.com/a/chat/s/23cdec35-eff3-4e26-998e-7988eb3efee7)

## 1. Установка зависимостей

bash

pip install psycopg2 pytest pytest-html

## 2. Конфигурация тестов (config.py)

python

import psycopg2
from dataclasses import dataclass

@dataclass
class DBConfig:
    host: str = "localhost"
    port: int = 5432
    user: str = "postgres"
    password: str = "your_password"
    
    db_filial1: str = "filial1"
    db_filial2: str = "filial2"

class DatabaseManager:
    def __init__(self, config: DBConfig):
        self.config = config
    
    def get_connection(self, database: str):
        return psycopg2.connect(
            host=self.config.host,
            port=self.config.port,
            user=self.config.user,
            password=self.config.password,
            database=database
        )
    
    def execute_query(self, database: str, query: str, params=None, fetch=False):
        conn = self.get_connection(database)
        try:
            with conn.cursor() as cursor:
                cursor.execute(query, params)
                if fetch:
                    return cursor.fetchall()
                conn.commit()
                return cursor.rowcount
        finally:
            conn.close()

# Конфигурация
config = DBConfig()
db_manager = DatabaseManager(config)

## 3. Базовый класс для тестов (test_base.py)

python

import pytest
from config import db_manager, config

class BaseSyncTest:
    """Базовый класс для всех тестов синхронизации"""
    
    def setup_method(self):
        """Очистка данных перед каждым тестом"""
        self.clean_test_data()
    
    def clean_test_data(self):
        """Очистка тестовых данных в обеих базах"""
        clean_queries = [
            "DELETE FROM Conflist",
            "DELETE FROM EmplHistory",
            "DELETE FROM Employee WHERE EmplCode >= 1000",
            "DELETE FROM Positions WHERE PosCode >= 100"
        ]
        
        for db in [config.db_filial1, config.db_filial2]:
            for query in clean_queries:
                try:
                    db_manager.execute_query(db, query)
                except Exception as e:
                    print(f"Warning: {e}")
    
    def make_snapshot(self, database: str):
        """Создание снимка данных"""
        query = "SELECT * FROM make_data_snapshot()"
        return db_manager.execute_query(database, query, fetch=True)
    
    def get_employee_count(self, database: str, filial: int = None):
        """Получить количество сотрудников"""
        if filial:
            query = "SELECT COUNT(*) FROM Employee WHERE Filial = %s"
            return db_manager.execute_query(database, query, (filial,), fetch=True)[0][0]
        else:
            query = "SELECT COUNT(*) FROM Employee"
            return db_manager.execute_query(database, query, fetch=True)[0][0]
    
    def get_conflict_count(self, database: str):
        """Получить количество конфликтов"""
        query = "SELECT COUNT(*) FROM Conflist"
        return db_manager.execute_query(database, query, fetch=True)[0][0]
    
    def add_employee(self, database: str, employee_data: dict):
        """Добавить сотрудника"""
        query = """
        INSERT INTO Employee (EmplCode, Name, Surname, Patronymic, Birthday, Passport, PosCode, Filial)
        VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """
        return db_manager.execute_query(database, query, tuple(employee_data.values()))
    
    def add_position(self, database: str, position_data: dict):
        """Добавить должность"""
        query = """
        INSERT INTO Positions (PosCode, PosName, ParentPos, Filial)
        VALUES (%s, %s, %s, %s)
        """
        return db_manager.execute_query(database, query, tuple(position_data.values()))
    
    def add_employment_history(self, database: str, history_data: dict):
        """Добавить запись в историю"""
        query = """
        INSERT INTO EmplHistory (EmplCode, ChangeDate, Surname, Passport, PosCode, Action)
        VALUES (%s, %s, %s, %s, %s, %s)
        """
        return db_manager.execute_query(database, query, tuple(history_data.values()))

## 4. Основные тесты (test_sync_scenarios.py)

python

import pytest
from datetime import date, datetime
from test_base import BaseSyncTest

class TestSyncScenarios(BaseSyncTest):
    """Тестовые сценарии синхронизации"""
    
    def test_01_sync_new_employee_from_filial1(self):
        """Тест 1: Синхронизация нового сотрудника из Ф1 в Ф2"""
        print("\n=== Тест 1: Синхронизация нового сотрудника из Ф1 в Ф2 ===")
        
        # ШАГ 1: Подготовка
        initial_count_f2 = self.get_employee_count(config.db_filial2, filial=2)
        print(f"Начальное количество сотрудников в Ф2: {initial_count_f2}")
        
        # ШАГ 2: Добавляем нового сотрудника в Ф1
        new_employee = {
            'EmplCode': 1003,
            'Name': 'Сергей',
            'Surname': 'Козлов', 
            'Patronymic': 'Алексеевич',
            'Birthday': date(1990, 5, 5),
            'Passport': '4444444444',
            'PosCode': 2,
            'Filial': 1
        }
        
        self.add_employee(config.db_filial1, new_employee)
        
        # Добавляем запись в историю
        history_data = {
            'EmplCode': 1003,
            'ChangeDate': date.today(),
            'Surname': 'Козлов',
            'Passport': '4444444444', 
            'PosCode': 2,
            'Action': 'Hired'
        }
        self.add_employment_history(config.db_filial1, history_data)
        
        print("Добавлен новый сотрудник в Ф1")
        
        # ШАГ 3: Эмуляция синхронизации (в реальности здесь будет job)
        self.emulate_sync()
        
        # ШАГ 4: Проверка результатов
        final_count_f2 = self.get_employee_count(config.db_filial2, filial=2)
        conflict_count = self.get_conflict_count(config.db_filial2)
        
        print(f"Конечное количество сотрудников в Ф2: {final_count_f2}")
        print(f"Количество конфликтов: {conflict_count}")
        
        # Проверки
        assert final_count_f2 == initial_count_f2 + 1, "Количество сотрудников в Ф2 должно увеличиться на 1"
        assert conflict_count == 0, "Не должно быть конфликтов"
        
        # Проверяем, что сотрудник появился в Ф2
        employee_in_f2 = self.get_employee_by_code(config.db_filial2, 1003)
        assert employee_in_f2 is not None, "Сотрудник должен быть в Ф2"
        assert employee_in_f2[2] == 'Козлов', "Фамилия должна совпадать"
    
    def test_02_employee_duplication_full_match(self):
        """Тест 2: Обработка полного дублирования сотрудников"""
        print("\n=== Тест 2: Обработка полного дублирования сотрудников ===")
        
        # ШАГ 1: Добавляем одинаковых сотрудников в оба филиала
        employee_data = {
            'EmplCode': 1004,
            'Name': 'Алексей',
            'Surname': 'Петров',
            'Patronymic': 'Сергеевич', 
            'Birthday': date(1985, 10, 15),
            'Passport': '5555555555',
            'PosCode': 1,
            'Filial': 1
        }
        
        self.add_employee(config.db_filial1, employee_data)
        
        employee_data['Filial'] = 2
        self.add_employee(config.db_filial2, employee_data)
        
        print("Добавлены одинаковые сотрудники в оба филиала")
        
        # ШАГ 2: Эмуляция синхронизации
        self.emulate_sync()
        
        # ШАГ 3: Проверка отсутствия дублирования
        duplicate_count = self.check_duplicate_employees()
        conflict_count = self.get_conflict_count(config.db_filial1)
        
        print(f"Найдено дубликатов: {duplicate_count}")
        print(f"Количество конфликтов: {conflict_count}")
        
        assert duplicate_count == 0, "Не должно быть полных дубликатов"
        assert conflict_count == 0, "Не должно быть конфликтов при полном совпадении"
    
    def test_03_partial_match_conflict(self):
        """Тест 3: Обработка конфликта при частичном совпадении"""
        print("\n=== Тест 3: Обработка конфликта при частичном совпадении ===")
        
        # ШАГ 1: Добавляем сотрудников с частичным совпадением
        employee_f1 = {
            'EmplCode': 1005,
            'Name': 'Дмитрий',
            'Surname': 'Смирнов',
            'Patronymic': 'Викторович',
            'Birthday': date(1988, 3, 20),
            'Passport': '6666666666', 
            'PosCode': 2,
            'Filial': 1
        }
        
        employee_f2 = {
            'EmplCode': 2005, 
            'Name': 'Дмитрий',
            'Surname': 'Смирнов', 
            'Patronymic': 'Викторович',
            'Birthday': date(1988, 3, 20),  # Совпадают ФИО и дата рождения
            'Passport': '7777777777',       # Но разный паспорт!
            'PosCode': 3,
            'Filial': 2
        }
        
        self.add_employee(config.db_filial1, employee_f1)
        self.add_employee(config.db_filial2, employee_f2)
        
        print("Добавлены сотрудники с частичным совпадением (разные паспорта)")
        
        # ШАГ 2: Эмуляция синхронизации
        self.emulate_sync()
        
        # ШАГ 3: Проверка конфликта
        conflict_count_f1 = self.get_conflict_count(config.db_filial1)
        conflict_count_f2 = self.get_conflict_count(config.db_filial2)
        
        print(f"Конфликтов в Ф1: {conflict_count_f1}")
        print(f"Конфликтов в Ф2: {conflict_count_f2}")
        
        assert conflict_count_f1 > 0 or conflict_count_f2 > 0, "Должен быть зафиксирован конфликт"
        
        # Проверяем, что данные не изменились
        employee1 = self.get_employee_by_code(config.db_filial1, 1005)
        employee2 = self.get_employee_by_code(config.db_filial2, 2005)
        
        assert employee1[5] == '6666666666', "Паспорт в Ф1 не должен измениться"
        assert employee2[5] == '7777777777', "Паспорт в Ф2 не должен измениться"
    
    def test_04_employment_history_sync(self):
        """Тест 4: Синхронизация истории трудоустройства"""
        print("\n=== Тест 4: Синхронизация истории трудоустройства ===")
        
        # ШАГ 1: Добавляем сотрудника и историю в Ф1
        employee_data = {
            'EmplCode': 1006,
            'Name': 'Ольга',
            'Surname': 'Иванова',
            'Patronymic': 'Петровна',
            'Birthday': date(1992, 7, 12),
            'Passport': '8888888888',
            'PosCode': 4,
            'Filial': 1
        }
        self.add_employee(config.db_filial1, employee_data)
        
        history_data = {
            'EmplCode': 1006,
            'ChangeDate': date.today(),
            'Surname': 'Иванова',
            'Passport': '8888888888',
            'PosCode': 4, 
            'Action': 'Hired'
        }
        self.add_employment_history(config.db_filial1, history_data)
        
        initial_history_count = self.get_history_count(config.db_filial2, 1006)
        
        # ШАГ 2: Синхронизация
        self.emulate_sync()
        
        # ШАГ 3: Проверка синхронизации истории
        final_history_count = self.get_history_count(config.db_filial2, 1006)
        
        print(f"История до синхронизации: {initial_history_count}")
        print(f"История после синхронизации: {final_history_count}")
        
        assert final_history_count == initial_history_count + 1, "История должна синхронизироваться"
    
    def test_05_conflict_resolution(self):
        """Тест 5: Разрешение конфликта"""
        print("\n=== Тест 5: Разрешение конфликта ===")
        
        # Создаем конфликтную ситуацию
        self.test_03_partial_match_conflict()
        
        # ШАГ 1: Разрешаем конфликт (обновляем данные в Ф2)
        update_query = """
        UPDATE Employee 
        SET Passport = '6666666666'
        WHERE EmplCode = 2005
        """
        db_manager.execute_query(config.db_filial2, update_query)
        
        # Очищаем конфликты
        db_manager.execute_query(config.db_filial1, "DELETE FROM Conflist")
        db_manager.execute_query(config.db_filial2, "DELETE FROM Conflist")
        
        print("Конфликт разрешен вручную")
        
        # ШАГ 2: Повторная синхронизация
        self.emulate_sync()
        
        # ШАГ 3: Проверка
        conflict_count = self.get_conflict_count(config.db_filial1)
        duplicate_count = self.check_duplicate_employees()
        
        print(f"Конфликтов после разрешения: {conflict_count}")
        print(f"Дубликатов после разрешения: {duplicate_count}")
        
        assert conflict_count == 0, "После разрешения не должно быть конфликтов"
        assert duplicate_count == 0, "Не должно быть дубликатов"
    
    # Вспомогательные методы
    def emulate_sync(self):
        """Эмуляция процесса синхронизации"""
        # В реальной системе здесь будет вызов вашего job синхронизации
        # Для тестов просто делаем паузу
        import time
        time.sleep(1)
        print("Синхронизация выполнена")
    
    def get_employee_by_code(self, database: str, empl_code: int):
        """Получить сотрудника по коду"""
        query = "SELECT * FROM Employee WHERE EmplCode = %s"
        result = db_manager.execute_query(database, query, (empl_code,), fetch=True)
        return result[0] if result else None
    
    def get_history_count(self, database: str, empl_code: int):
        """Получить количество записей в истории для сотрудника"""
        query = "SELECT COUNT(*) FROM EmplHistory WHERE EmplCode = %s"
        return db_manager.execute_query(database, query, (empl_code,), fetch=True)[0][0]
    
    def check_duplicate_employees(self):
        """Проверить наличие дубликатов сотрудников"""
        query = """
        SELECT COUNT(*) FROM (
            SELECT Surname, Name, Patronymic, Birthday, Passport, COUNT(*)
            FROM Employee
            GROUP BY Surname, Name, Patronymic, Birthday, Passport
            HAVING COUNT(*) > 1
        ) AS duplicates
        """
        result1 = db_manager.execute_query(config.db_filial1, query, fetch=True)[0][0]
        result2 = db_manager.execute_query(config.db_filial2, query, fetch=True)[0][0]
        return result1 + result2

## 5. Запуск тестов (run_tests.py)

python

import pytest
import subprocess
import sys
from datetime import datetime

def run_tests():
    """Запуск всех тестов с генерацией отчета"""
    print("=== Запуск автотестов системы синхронизации ===")
    print(f"Время запуска: {datetime.now()}")
    
    # Параметры pytest
    pytest_args = [
        "test_sync_scenarios.py",
        "-v",  # Подробный вывод
        "--html=test_report.html",  # HTML отчет
        "--self-contained-html",
        "--capture=sys"  # Для вывода print
    ]
    
    # Запуск тестов
    exit_code = pytest.main(pytest_args)
    
    if exit_code == 0:
        print("\n✅ Все тесты прошли успешно!")
    else:
        print(f"\n❌ Часть тестов не прошла. Код выхода: {exit_code}")
    
    print(f"\nОтчет сохранен в: test_report.html")
    return exit_code

if __name__ == "__main__":
    result = run_tests()
    sys.exit(result)

## 6. Утилиты для работы с БД (db_utils.py)

python

from config import db_manager, config

def initialize_test_data():
    """Инициализация тестовых данных в обеих базах"""
    
    # Очистка старых данных
    cleanup_queries = [
        "DELETE FROM Conflist",
        "DELETE FROM EmplHistory", 
        "DELETE FROM Employee",
        "DELETE FROM Positions"
    ]
    
    for db in [config.db_filial1, config.db_filial2]:
        for query in cleanup_queries:
            try:
                db_manager.execute_query(db, query)
            except Exception as e:
                print(f"Warning during cleanup: {e}")
    
    # Добавление тестовых должностей
    positions = [
        (1, 'Менеджер', None, 1),
        (2, 'Разработчик', None, 1),
        (3, 'Аналитик', None, 2),
        (4, 'Дизайнер', None, 2)
    ]
    
    for db in [config.db_filial1, config.db_filial2]:
        for pos in positions:
            query = "INSERT INTO Positions (PosCode, PosName, ParentPos, Filial) VALUES (%s, %s, %s, %s)"
            db_manager.execute_query(db, query, pos)
    
    # Добавление тестовых сотрудников
    employees_f1 = [
        (1001, 'Иван', 'Иванов', 'Иванович', '1990-01-01', '1234567890', 1, 1),
        (1002, 'Петр', 'Петров', 'Петрович', '1991-02-02', '1111111111', 2, 1)
    ]
    
    employees_f2 = [
        (2001, 'Мария', 'Сидорова', 'Ивановна', '1992-03-03', '2222222222', 3, 2),
        (2002, 'Анна', 'Смирнова', 'Петровна', '1993-04-04', '3333333333', 4, 2)
    ]
    
    for emp in employees_f1:
        query = """
        INSERT INTO Employee (EmplCode, Name, Surname, Patronymic, Birthday, Passport, PosCode, Filial)
        VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """
        db_manager.execute_query(config.db_filial1, query, emp)
    
    for emp in employees_f2:
        query = """
        INSERT INTO Employee (EmplCode, Name, Surname, Patronymic, Birthday, Passport, PosCode, Filial)
        VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """
        db_manager.execute_query(config.db_filial2, query, emp)
    
    print("✅ Тестовые данные инициализированы в обеих базах")

def check_database_health():
    """Проверка состояния баз данных"""
    print("\n=== Проверка состояния баз данных ===")
    
    for db_name in [config.db_filial1, config.db_filial2]:
        try:
            # Проверяем подключение
            conn = db_manager.get_connection(db_name)
            
            # Проверяем основные таблицы
            tables = ['Employee', 'Positions', 'EmplHistory', 'Conflist']
            for table in tables:
                query = f"SELECT COUNT(*) FROM {table}"
                count = db_manager.execute_query(db_name, query, fetch=True)[0][0]
                print(f"📊 {db_name}.{table}: {count} записей")
            
            conn.close()
            print(f"✅ База {db_name} в порядке")
            
        except Exception as e:
            print(f"❌ Ошибка при проверке {db_name}: {e}")

if __name__ == "__main__":
    initialize_test_data()
    check_database_health()

## 7. Запуск

bash

# 1. Инициализация тестовых данных
python db_utils.py

# 2. Запуск всех тестов
python run_tests.py

# 3. Или запуск через pytest напрямую
pytest test_sync_scenarios.py -v

## Особенности реализации:

1. **Изоляция тестов** - каждый тест запускается с чистым состоянием
    
2. **Подробное логирование** - все шаги теста выводятся в консоль
    
3. **HTML отчет** - генерируется подробный отчет о тестировании
    
4. **Гибкая конфигурация** - легко изменить параметры подключения
    
5. **Эмуляция синхронизации** - в реальной системе замените на вызов вашего ETL-процесса
    

Тесты покрывают все основные сценарии из вашего плана тестирования!